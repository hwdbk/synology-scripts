#!/bin/bash
# usage: backup_update_copy [pwdfile] [path/]backupsetname_disknum.lst [ mountonly | dryrun | md5 [prev_md5_file.md5 ] ]

# set srcdir: the rsync source, which may be a remote rsync server, or a local path
srcdir=rsync://yourrsyncaccount@yourserver/NetBackup
# set bupdir: the directory where the unencrypted mounts of the backup disks will appear e.g. ($bupdir/20201118_001)
bupdir="/volumeSATA1/satashare1-1"

if [[ $1 != *.lst && -f $1 ]] ; then pwdfile=$1 ; shift ; chmod 000 "$pwdfile" ; fi # restrict access just in case one forgot

if [[ ! -d "$bupdir" ]] ; then echo "Backup target directory $bupdir not found - exit" ; exit 1 ; fi

if [[ $1 == *.lst && -f $1 ]] ; then
	# assume backup_diskset_copy [path/]backupsetname_disknum.lst [ options ]
	wrkdir=$(dirname "$1") ; if [[ ${wrkdir:0:1} != '/' ]] ; then wrkdir="$(pwd)/$wrkdir" ; fi
	name=$(basename "$1" | sed -e 's/_[0-9][0-9][0-9].lst$//')
	dn=$(basename "$1" | sed -e 's/.*_\([0-9][0-9][0-9]\).lst$/\1/' -e 's/[0]*//')
	shift
	opts=("$@")
	if [[ ${opts[0]} == "dryrun" ]] ; then dryrun=y ; fi
else
	echo "usage: $0 [pwdfile] backupsetname_disknum.lst [ mountonly | dryrun | md5 [prev_md5_file.md5 ] ]" >&2
	echo "this script will process the .lst 'todo' recipe for a given backup set disk. it will 'pull' the files" >&2
	echo "and write them on a local mounted file system (this is because files also can be deleted/moved/renamed)" >&2
	echo "which is tricky to do through rsync alone." >&2
	echo "note:  when mountonly or dryrun is specified, no log file is created and md5 verification is skipped" >&2
	echo "note:  the pwdfile is used if the files are fetched with rsync over the network; for local (filesystem)" >&2
	echo "       rsync, this is not necessary. the copy method is hardcoded in the copy section; two examples are given" >&2
	exit 1
fi

dsk=$(printf "%s_%03d" "$name" "$dn")
#echo "$bupdir#$wrkdir#$name#$dn#$dsk#${opts[@]}#" ; exit

if [[ -d "$bupdir/$dsk" ]] ; then
	echo "INFO: $bupdir/$dsk exists - assuming it is the mounted backup disk $dsk"
else
	echo "INFO: $bupdir/$dsk not found"
	echo "Mounting $bupdir/@$dsk@ on $bupdir/$dsk"
	mkdir -pv "$bupdir/@$dsk@"
	mkdir -p  "$bupdir/$dsk"
	if (( $(df -P | grep "$bupdir/$dsk" | wc -l) == 0 )) ; then
		mount.ecryptfs "$bupdir/@$dsk@" "$bupdir/$dsk" -o rw,noauto,ecryptfs_cipher=aes,ecryptfs_key_bytes=32,ecryptfs_passthrough=n,ecryptfs_enable_filename_crypto=y
		ls -l "$bupdir/$dsk"
	else
		echo "Target directory $bupdir/$dsk already mounted"
		# if the target dir is already mounted, this script can also be run from the task manager (doesn't require user input in that case)
	fi
fi
if [[ ${opts[0]} = "mountonly" ]] ; then exit ; fi

bdl="$wrkdir/$dsk.lst"
if [[ ! -f "$bdl" ]] ; then echo "Backup todo list $bdl not found - exit" ; exit 1 ; fi
MOVINGSTR="Moving and renaming files on"
CLEANUPSTR="Cleanup of empty directories on"
log="$wrkdir/$dsk.log"
if [[ -n $dryrun ]] ; then
	log=/dev/null # don't overwrite log file in dryrun (could be enabled if necessary)
elif [[ -f $log ]] ; then
	# probe (old/previous) log file to see how far we got, but need to do this before we rewrite the log file, obviously
	if grep -q "^$MOVINGSTR "  $log ; then movingstr=y  ; fi
	if grep -q "^$CLEANUPSTR " $log ; then cleanupstr=y ; fi
fi

echo "Updating backup disk $dn from disk set \"$name\" ($bdl) in $bupdir" | tee $log
if [[ -n $dryrun ]] ; then echo ">>DRY RUN<<" | tee -a $log ; fi
dlist=$(mktemp) # collect a list of touched directories to speed up cleanup

# .lst 'todo' recipe format (output from md5diff):
#   f1   f2      f3      f4           f5        f6        f7        f8
#   -  moddate  size  [md5sum|-]     path
#   =  moddate  size  [md5sum|-]     path       ->      newpath
#   >  moddate  size  [md5sum|-]     path       ->      newpath
#   *  moddate  size     ->       newmoddate  newsize  [md5sum|-]  path
#   +  moddate  size  [md5sum|-]     path

echo "Deleting files on $dsk" | tee -a $log
# cleanup of files that are no longer in the copy set
if [[ -n $movingstr ]] ; then # previous run had already progressed to $MOVINGSTR
	echo "- skipping (was already performed according to $log)" | tee -a $log
else
	grep '^-' "$bdl" | cut -f 5 | while read f ; do
		if [[ -n $dryrun ]] ; then
			echo "Will remove: $bupdir/$dsk/$f" | tee -a $log
		else
			if [[ ! -f "$bupdir/$dsk/$f" ]] ; then
				echo "WARNING: can't delete: $f not found on $dsk" | tee -a $log
			else
				rm "$bupdir/$dsk/$f" ; # no output to log or stdout, only stderr if rm fails
			fi
		fi
		echo "$(dirname "$bupdir/$dsk/$f")" >> $dlist # directory could now be empty
	done
fi

echo "$MOVINGSTR $dsk" | tee -a $log
if [[ -n $cleanupstr ]] ; then # previous run had already progressed to $CLEANUPSTR
	echo "- skipping (was already performed according to $log)" | tee -a $log
else
	grep '^[=>]' "$bdl" | while IFS=$'\t' read f1 f1 f3 f4 f5 f6 f7 ; do #
		if [[ ! -f "$bupdir/$dsk/$f5" ]] ; then echo "WARNING: can't move: $f5 not found on $dsk" | tee -a $log ; fi # just checking...
		if [[   -f "$bupdir/$dsk/$f7" ]] ; then echo "WARNING: can't move: $f7 already exists on $dsk - skipping" | tee -a $log ; continue ; fi # just checking...
		if [[ -n $dryrun ]] ; then
			echo "Will move: $bupdir/$dsk/$f5 to $bupdir/$dsk/$f7" | tee -a $log
		else
			mkdir -p "$(dirname "$bupdir/$dsk/$f7")"
			mv "$bupdir/$dsk/$f5" "$bupdir/$dsk/$f7" ; # no output to log or stdout, only stderr
		fi
		echo "$(dirname "$bupdir/$dsk/$f5")" >> $dlist # directory could now be empty
	done
fi

# cleanup any trailing empty directories
if [[ -n $dryrun ]] ; then
	echo "Skipping empty directory cleanup (in dry run, the relevant directories are not yet emptied)" | tee -a $log
	sort -u $dlist | while read f ; do echo "Will (try to) remove directory: $f" ; done | tee -a log
else
	echo "$CLEANUPSTR $dsk" | tee -a $log
#	find "$bupdir/$dsk" -depth -mindepth 1 -type d -empty -exec rmdir {} \; # no output to log or stdout, only stderr
	sort -u $dlist | while read f ; do rmdir "$f" 2>/dev/null ; done # could use xargs here
fi
rm $dlist
df -B 1 "$bupdir/$dsk" | tee -a $log # log how much space was deleted / will be reused

echo "Copying modified and new files to $dsk" | tee -a $log
# copy files with rsync - using rsync also makes it possible to resume copying after the process got aborted
# note: with --files-from, the -r (--recursive) from -a is not implied (see man page), so if the input list contains directories, only the directory is copied, not its contents (that's how it should be in this case)
# note: the --delete-before option doesn't seem to work to clean up any rogue files before copying because it works off an explicit input list - it only copies new and modified files
#       (for instance, when reusing the disk a second time and reusing as many files as possible). hence the files need to be cleaned out explicitly, using the ^- wipe list from the md5diff output
# note: --inplace makes sure rsyncd doesn't create the .filename.ext.uniquesuffix tmp files, which cause problems with long file names and the ecryptfs limit
flist=$(mktemp)
grep -P '^\*' "$bdl" | cut -f 8 >  $flist # the modified files
grep -P '^\+' "$bdl" | cut -f 5 >> $flist # the new files
if [[ -z $pwdfile ]] ; then
	# interactive mode
	tmp=$(mktemp) ; chmod 000 $tmp ; echo -n "Password: " ; read -s pwd ; echo "$pwd" > $tmp ; pwdfile=$tmp
fi
if [[ -n $dryrun ]] ; then
	rsyncopts=-avn
else
	rsyncopts=-av
fi
#rsync $rsyncopts --files-from="$flist" --relative --dirs / "$bupdir/$dsk" | tee -a $log # use rsync to copy from and to local filesystem
rsync $rsyncopts -W --files-from="$flist" --relative --dirs --copy-dirlinks --inplace --password-file="$pwdfile" "$srcdir" "$bupdir/$dsk" | tee -a $log # use rsync to read files from remote server and store on local file system
if [[ -n $tmp ]] ; then rm $tmp ; fi # delete pwdfile
rm $flist

# re-read the disk by calculating the md5 check sums and register the moddate and size
# the catenation of these files can be crosschecked with the master md5 files using md5diff
# strip the $bupdir base path from the files listed so they start with $dsk/...
df -B 1 "$bupdir/$dsk" | tee -a $log # log the final utilisation of the disk
if [[ -n $dryrun ]] ; then
	echo "Skipping verification of $bupdir/$dsk to $wrkdir/$dsk.[fst|md5] (dry run)" | tee -a $log
	# and don't unmount
else
	if [[ ${opts[0]} == md5 ]] ; then
		# create an .md5 file listing
		if [[ -z ${opts[1]} ]] ; then
			# full md5 scan
			echo "Verifying $dsk (save output in $wrkdir/$dsk.md5|err)" | tee -a $log
			savepwd=$(pwd) ; cd "$bupdir/$dsk"
			mkfilelist_md5 * > "$wrkdir/$dsk.md5" 2> "$wrkdir/$dsk.err"
			cd "$savepwd"
		elif [[ -f ${opts[1]} ]] ; then
			# incremental md5 scan using previous scan
			prev=${opts[1]}
			# prepend current path if $prev path is not absolute, to make it absolute and work when whe're cd-ing into $bupdir/$dsk
			if [[ ${prev:0:1} != '/' ]] ; then prev="$(pwd)/$prev" ; fi
			echo "Verifying $dsk (using previous scan $prev, save output in $wrkdir/$dsk.md5|err)" | tee -a $log
			savepwd=$(pwd) ; cd "$bupdir/$dsk"
			mkfilelist_md5 -f $prev * > "$wrkdir/$dsk.md5" 2> "$wrkdir/$dsk.err"
			cd "$savepwd"
		else
			echo "Error: wrong parameter ${opts[1]} - skipping md5sum verification" | tee -a $log
		fi
	else
		# create an .fst file listing
		echo "Fast scan of $dsk (save output in $wrkdir/$dsk.fst|err)" | tee -a $log
		mkfilelist_fast "$bupdir/$dsk" | sed -e "s#\t$bupdir/$dsk/#\t#" > "$wrkdir/$dsk.fst" 2> "$wrkdir/$dsk.err"
	fi
#	echo "Unmounting $dsk"
#	umount "$bupdir/$dsk"
#	rmdir "$bupdir/$dsk"
fi
echo "Done" | tee -a $log

#EOF
